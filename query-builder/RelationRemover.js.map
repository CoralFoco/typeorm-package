{"version":3,"sources":["../../src/query-builder/RelationRemover.ts"],"names":[],"mappings":"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","file":"RelationRemover.js","sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\";\nimport { ObjectLiteral } from \"../common/ObjectLiteral\";\nimport { QueryExpressionMap } from \"./QueryExpressionMap\";\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryBuilder: QueryBuilder<any>,\n        protected expressionMap: QueryExpressionMap\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs remove operation on a relation.\n     */\n    async remove(value: any | any[], userLogin: string): Promise<void> {\n        const relation = this.expressionMap.relationMetadata;\n\n        if (relation.isOneToMany) {\n            // if (this.expressionMap.of instanceof Array)\n            //     throw new Error(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n\n            // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n            const ofs =\n                this.expressionMap.of instanceof Array\n                    ? this.expressionMap.of\n                    : [this.expressionMap.of];\n            const values = value instanceof Array ? value : [value];\n\n            const updateSet: ObjectLiteral = {};\n            relation.inverseRelation!.joinColumns.forEach(column => {\n                updateSet[column.propertyName] = null;\n            });\n\n            const parameters: ObjectLiteral = {};\n            const conditions: string[] = [];\n            ofs.forEach((of, ofIndex) => {\n                conditions.push(\n                    ...values.map((value, valueIndex) => {\n                        return [\n                            ...relation.inverseRelation!.joinColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"joinColumn_\" +\n                                        ofIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex;\n                                    parameters[parameterName] =\n                                        of instanceof Object\n                                            ? column.referencedColumn!.getEntityValue(\n                                                  of\n                                              )\n                                            : of;\n                                    return `${column.propertyPath} = :${parameterName}`;\n                                }\n                            ),\n                            ...relation.inverseRelation!.entityMetadata.primaryColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"primaryColumn_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex;\n                                    parameters[parameterName] =\n                                        value instanceof Object\n                                            ? column.getEntityValue(value)\n                                            : value;\n                                    return `${column.propertyPath} = :${parameterName}`;\n                                }\n                            )\n                        ].join(\" AND \");\n                    })\n                );\n            });\n            const condition = conditions\n                .map(str => \"(\" + str + \")\")\n                .join(\" OR \");\n            if (!condition) return;\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute(userLogin);\n        } else {\n            // many to many\n\n            const junctionMetadata = relation.junctionEntityMetadata!;\n            const ofs =\n                this.expressionMap.of instanceof Array\n                    ? this.expressionMap.of\n                    : [this.expressionMap.of];\n            const values = value instanceof Array ? value : [value];\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n            const secondColumnValues = relation.isManyToManyOwner\n                ? values\n                : ofs;\n\n            const parameters: ObjectLiteral = {};\n            const conditions: string[] = [];\n            firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n                conditions.push(\n                    ...secondColumnValues.map(\n                        (secondColumnVal, secondColumnValIndex) => {\n                            return [\n                                ...junctionMetadata.ownerColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"firstValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex;\n                                        parameters[parameterName] =\n                                            firstColumnVal instanceof Object\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      firstColumnVal\n                                                  )\n                                                : firstColumnVal;\n                                        return `${column.databaseName} = :${parameterName}`;\n                                    }\n                                ),\n                                ...junctionMetadata.inverseColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"secondValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex;\n                                        parameters[parameterName] =\n                                            secondColumnVal instanceof Object\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      secondColumnVal\n                                                  )\n                                                : secondColumnVal;\n                                        return `${column.databaseName} = :${parameterName}`;\n                                    }\n                                )\n                            ].join(\" AND \");\n                        }\n                    )\n                );\n            });\n            const condition = conditions\n                .map(str => \"(\" + str + \")\")\n                .join(\" OR \");\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .delete()\n                .from(junctionMetadata.tableName)\n                .where(condition)\n                .setParameters(parameters)\n                .execute(userLogin);\n        }\n    }\n}\n"],"sourceRoot":".."}